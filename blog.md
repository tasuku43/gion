# Git worktreeの作成・移動・片付けをラクにする「gion」を作りました

AIエージェントで並行開発を回すようになって、Git worktreeに辿り着きました。  
でも worktree だけだと「作業場所の運用ルール」までは自分で作る必要があって、手癖になるまで時間がかかりそうでした。  
さらに増えると「今どこで何してるんだっけ？」の認知負荷が上がり、「これ消していいんだっけ？」が怖くなって片付けが止まる。  
だから、複数のworktreeをタスク（workspace）単位で束ねて管理できるように、gionというツールを作ってみました。

<-- XのPostはる -->

## 0. 仕組み（gion.yaml と manifestサブコマンドの関係）

この章では、細かいサブコマンドの話に入る前に、gionの全体像だけ押さえます。  
中心にあるのは `gion.yaml` で、ここに「こうなっていてほしい」（望ましい状態）を置きます。  
その状態は、YAMLを直接編集してもいいし、人間向けの入口として `manifest` サブコマンドで更新してもいい——どちらも最終的に同じ `gion.yaml` を書き換えるだけです。  
そして `plan` で差分を確認してから `apply` で実体（作業場所）を揃える、という関係になっています。

用語だけ補足すると、**Git worktree** はブランチ（や特定コミット）をチェックアウトした作業用ディレクトリです。  
一方、ここで言う **workspace** は「タスク単位の箱」で、その中に1つ以上のworktree（必要なら複数リポジトリのworktree）を束ねて扱います。

イメージとしては、だいたい次のようなディレクトリ構造になります（`GION_ROOT` 配下だけを触る前提）。

```text
GION_ROOT/
├─ gion.yaml           # 望ましい状態（inventory）
├─ bare/               # 共有のbare repoストア
└─ workspaces/         # タスク単位のworkspace
   ├─ PROJ-123/        # workspace_id（タスク）
   │  ├─ backend/      # worktree（repo: backend）
   │  ├─ frontend/
   │  └─ docs/
   └─ PROJ-456/
      └─ backend/
```

<!-- Plan が出て、その後に確認プロンプトが出る画面（「いきなり実行しない」を一枚で）-->


———

## 1. 作る（Planで差分を見て、Applyでまとめて作る）

workspaceを「作る」操作は、`gion manifest add` コマンド（入口 / mode）か、`gion.yaml` の直接編集で行います。  
どちらの場合も、まず “望ましい状態” を宣言して `gion plan` で差分（何が作られるか）を確認し、納得できたら `gion apply` でまとめて作る——という流れです。

### 1-1. 入口（mode）は4つある

入口は `repo` / `issue` / `review` / `preset` の4つです。  
始め方に合わせて入口を選べるだけで、行き着く先は同じで、最終的には `gion.yaml` に「こうしたい」を積んでいきます。

まず入口をインタラクティブに選ぶなら、これだけでOKです。
<!-- 画像を挟む -->

### 1-2. issue / review（まとめて積んで、一括で作る）

個人的に一番推したいのがここです。Issue（やPR）を複数選んで `gion.yaml` に積み、`plan` で差分を見てから、`apply` は1回だけ。並行開発の「机をまとめて出す」がかなりラクになります。

<!-- GIFを挟む -->

### 1-3. repo（workspaceを一つ作る）

とにかく最短で1つ作るなら `repo` が一番シンプルです。リポジトリとworkspace IDを指定して追加し、`plan` で作成内容を確認してから `apply` します。

<!-- 画像を挟む -->

### 1-4. preset（複数repoをworkspaceに束ねる）

workspaceは「タスク単位の箱」なので、backend + frontend + docs みたいに複数repoを束ねたくなります。presetを作っておけば、次からは `--preset` でまとめて積めます。

<!-- 画像を挟む -->

### 1-5. YAML直編集 vs manifest

`gion.yaml` は直接編集してもOKです。特に、すでにあるinventoryを「まとめて整える」用途に向いています。  
たとえば ブランチ名を直したいとき、複数workspaceを同時に削除・作成したいとき、既存の定義を更新しつつ整理したいとき、などです。

直編集のあとに `gion plan` を叩くと、削除・作成・更新がまとめて一覧できるので「何が起きるか」を落ち着いて確認できます。確認できたら `gion apply` で反映、という流れはmanifestと同じです。

<!-- 画像: Planで「削除・作成・更新」が同時に表示されるスクショ -->

———

## 2. 移動する（workspace/worktreeを検索して移動する）

worktreeが増えてくると、「あの作業どこでやってたっけ？」を思い出す時間が地味に効いてきます。  
gionの基本フロー（Plan/Apply）とは別に、移動だけを速くするための相棒が `giongo` です（brew/miseで入れると `gion` と一緒に入ってきます）。  
これは状態を一切変えず、目的地を選ぶところまでを担当します。

### 2-1. 検索して選んで移動する

`giongo` は workspace と worktree をまとめて一覧し、検索で絞って選べます。  

<!-- GIF: workspace/worktreeを検索して移動する -->
*workspace/worktreeを検索して移動する（giongo）*

### 2-2. シェル統合（軽く）

`giongo --print` は選んだパスを出力するだけなので、`cd` まで繋ぐには bash/zsh の関数が必要です（`eval "$(giongo init)"` を一度入れるだけ）。

———

## 3. 削除する（“自動で安全に減る”＋“危険なら止まる”）（900〜1400字）

- 章のゴール
  - worktreeが増え続けて破綻する問題を、気合ではなく仕組みで解く
- 章内の構造（順番固定）
  1. まず gc（自動・保守的）
     - 体験の核：作業の終わったworktreeのHEADがデフォルトブランチにマージ済みなら回収できる
     - 併せて言う：不確実なものは対象外（保守的）＝勝手に事故らない
     - 見せ場：gcの結果画（静止画で「除外される/されない」が読める形）
  2. 次に rm（手動・ガードレール）
     - 体験の核：消す前に dirty/未push/乖離/不明 を出してくれる、確認が前提
     - 見せ場：Plan に risk: / sync: が出る画＋確認プロンプト（静止画）
- 導入との呼応（短く1段落）
  - 自動は「確実に安全」だけ、手動は「判断材料を出す」＋「止まる」

———

## 4. まとめ（体験の要約＋次の一歩）（200〜400字）

- 3体験を一文ずつで畳む
  - 作る：入口が複数、まとめて展開できる（Issue起点が中心）
  - 移動：思い出さずに開ける
  - 削除：マージ済みは回収、危険なら止まる
- 次の一歩（リンク/導線）
  - READMEへの導線、インストール、まずはrepoモードから、など

———

## 画像/GIF設計（Zenn向け・最小構成案）

- 静止画4枚
  - 導入：Plan→確認
  - 作る：presetのツリー（backend + frontend + docs が見える）
  - 削除：gcの結果
  - 削除：rmのPlan（risk/sync）
- GIF 1〜2本（入れるならここだけ）
  - 作る：issueの複数選択（最優先、URLは実在のものを表示）
  - 移動：giongo絞り込み（余裕があれば）
