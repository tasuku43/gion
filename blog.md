# Git worktreeの作成・移動・片付けをラクにする「gion」を作りました

AIエージェントで並行開発を回すようになって、Git worktreeに辿り着きました。  
でも worktree だけだと「作業場所の運用ルール」までは自分で作る必要があって、手癖になるまで時間がかかりそうでした。  
さらに増えると「今どこで何してるんだっけ？」の認知負荷が上がり、「これ消していいんだっけ？」が怖くなって片付けが止まる。  
だから、複数のworktreeをタスク（workspace）単位で束ねて管理できるように、gionというツールを作ってみました。

<-- XのPostはる -->

## 0. 仕組み（gion.yaml と manifestサブコマンドの関係）

この章では、細かいサブコマンドの話に入る前に、gionの全体像だけ押さえます。  
中心にあるのは `gion.yaml` で、ここに「こうなっていてほしい」（望ましい状態）を置きます。  
その状態は、YAMLを直接編集してもいいし、人間向けの入口として `manifest` サブコマンドで更新してもいい——どちらも最終的に同じ `gion.yaml` を書き換えるだけです。  
そして `plan` で差分を確認してから `apply` で実体（作業場所）を揃える、という関係になっています。

用語だけ補足すると、**Git worktree** はブランチ（や特定コミット）をチェックアウトした作業用ディレクトリです。  
一方、ここで言う **workspace** は「タスク単位の箱」で、その中に1つ以上のworktree（必要なら複数リポジトリのworktree）を束ねて扱います。

イメージとしては、だいたい次のようなディレクトリ構造になります（`GION_ROOT` 配下だけを触る前提）。

```text
GION_ROOT/
├─ gion.yaml           # 望ましい状態（inventory）
├─ bare/               # 共有のbare repoストア
└─ workspaces/         # タスク単位のworkspace
   ├─ PROJ-123/        # workspace_id（タスク）
   │  ├─ backend/      # worktree（repo: backend）
   │  ├─ frontend/
   │  └─ docs/
   └─ PROJ-456/
      └─ backend/
```

<!-- Plan が出て、その後に確認プロンプトが出る画面（「いきなり実行しない」を一枚で）-->


———

## 1. 作る（入口を増やして“一気に展開”する）（1100〜1700字）

- 章のゴール（体験として）
  - 「作業机を出す」を、意思決定に寄せる（手順を減らす）
  - まとめて選んで、1回のapplyで揃うのが気持ちいい
- 章内の構造（おすすめ順・Issue主役に最適化）
  1. 4つの入口をまず並べる（1段落）
     - `repo` / `issue` / `review` / `preset`
     - 「入口が複数ある＝始め方に合わせられる」という言い方にする（機能説明は抑える）
  2. issue（まとめてピック→一括作成）が主役（山場）
     - “Issueを複数選ぶ → 1回のapply” を体験の中心に置く
     - review は「同じノリで使える近い入口」として短く添える（主役にしない）
     - 見せ場：ピッカーの複数選択（ここだけGIFが最有力）
     - 最小の根拠：`gion manifest add --issue <実在Issue URL>`（必要最小限の行数で）
  3. repo（最小の入口）を短く添える（理解の足場）
     - “1個だけ作る” の最短例として置く（深掘りしない）
     - 見せ場：Plan に + add workspace が出る静止画でも可
  4. preset（複数repoを1タスクに束ねる）
     - 「workspace＝作業机」の感覚をここで決定づける（1対1からの拡張）
     - 深掘り事例：backend + frontend + docs（これでツリー画像が強くなる）
     - 見せ場：`workspaces/<ID>/` 配下のツリー（静止画）
     - バリエーションは“本文で深掘りせず”に1〜2行で添える（例：backend+frontend、backend+docs、など）
  5. YAML直編集 vs manifest（導入の回収を短く）
     - 「直編集でもOK」「manifestはインタラクティブなフロントエンド」という整理だけ
     - 見せ場：`gion.yaml` の差分→ `gion plan`（静止画）

———

## 2. 移動する（作業場所を“思い出さない”）（600〜900字）

- 章のゴール
  - 増やしたworktreeを、迷わず開ける状態にする（運用のボトルネックは移動）
- 章内の構造
  1. “移動のコスト”を問題として置く
     - 「どこで作業してたっけ」が積もる、の1点に絞る
  2. giongo は“状態を変えない”と明言
     - apply系と混同させない補助線にする
  3. インタラクティブ検索→ジャンプ
     - 見せ場：絞り込みの動き（GIFが効く。軽くするなら静止画2枚でも可）
- 見せるもの
  - `eval "$(giongo init)"` は「一度だけ」扱いで軽く
  - 以降は「絞る→選ぶ→移動」の画だけで十分

———

## 3. 削除する（“自動で安全に減る”＋“危険なら止まる”）（900〜1400字）

- 章のゴール
  - worktreeが増え続けて破綻する問題を、気合ではなく仕組みで解く
- 章内の構造（順番固定）
  1. まず gc（自動・保守的）
     - 体験の核：作業の終わったworktreeのHEADがデフォルトブランチにマージ済みなら回収できる
     - 併せて言う：不確実なものは対象外（保守的）＝勝手に事故らない
     - 見せ場：gcの結果画（静止画で「除外される/されない」が読める形）
  2. 次に rm（手動・ガードレール）
     - 体験の核：消す前に dirty/未push/乖離/不明 を出してくれる、確認が前提
     - 見せ場：Plan に risk: / sync: が出る画＋確認プロンプト（静止画）
- 導入との呼応（短く1段落）
  - 自動は「確実に安全」だけ、手動は「判断材料を出す」＋「止まる」

———

## 4. まとめ（体験の要約＋次の一歩）（200〜400字）

- 3体験を一文ずつで畳む
  - 作る：入口が複数、まとめて展開できる（Issue起点が中心）
  - 移動：思い出さずに開ける
  - 削除：マージ済みは回収、危険なら止まる
- 次の一歩（リンク/導線）
  - READMEへの導線、インストール、まずはrepoモードから、など

———

## 画像/GIF設計（Zenn向け・最小構成案）

- 静止画4枚
  - 導入：Plan→確認
  - 作る：presetのツリー（backend + frontend + docs が見える）
  - 削除：gcの結果
  - 削除：rmのPlan（risk/sync）
- GIF 1〜2本（入れるならここだけ）
  - 作る：issueの複数選択（最優先、URLは実在のものを表示）
  - 移動：giongo絞り込み（余裕があれば）
